use std::{
  collections::{BTreeMap, BTreeSet},
  error::Error,
  fs,
  path::{Path, PathBuf},
};

#[path = "../fixture_corpus.rs"]
mod fixture_corpus;

fn main() -> Result<(), Box<dyn Error>> {
  let args = std::env::args().skip(1).collect::<Vec<_>>();
  match parse_mode(&args)? {
    GeneratorMode::Write { output_dir } => {
      let written_files = fixture_corpus::write_fixture_corpus(&output_dir)?;
      println!(
        "generated_xlsx_fixtures: {{\"dir\":\"{}\",\"files\":[{}]}}",
        output_dir.display(),
        written_files
          .iter()
          .map(|file_name| format!("\"{file_name}\""))
          .collect::<Vec<_>>()
          .join(","),
      );
    }
    GeneratorMode::VerifyCommitted { fixtures_dir } => {
      let verified_files = verify_fixture_corpus(&fixtures_dir)?;
      println!(
        "verified_xlsx_fixtures: {{\"dir\":\"{}\",\"files\":[{}]}}",
        fixtures_dir.display(),
        verified_files
          .iter()
          .map(|file_name| format!("\"{file_name}\""))
          .collect::<Vec<_>>()
          .join(","),
      );
    }
  }
  Ok(())
}

#[derive(Debug, PartialEq, Eq)]
enum GeneratorMode {
  Write { output_dir: PathBuf },
  VerifyCommitted { fixtures_dir: PathBuf },
}

fn parse_mode(args: &[String]) -> Result<GeneratorMode, Box<dyn Error>> {
  let mut output_dir: Option<PathBuf> = None;
  let mut verify_committed = false;
  let mut index = 0usize;

  while index < args.len() {
    match args[index].as_str() {
      "--output-dir" => {
        let Some(dir_value) = args.get(index + 1) else {
          return Err("--output-dir requires a following directory path".into());
        };
        output_dir = Some(PathBuf::from(dir_value));
        index += 2;
      }
      "--verify-committed" => {
        verify_committed = true;
        index += 1;
      }
      unknown => {
        return Err(
          format!(
            "Unknown argument '{unknown}'. Supported args: --output-dir <path>, --verify-committed"
          )
          .into(),
        )
      }
    }
  }

  let default_dir = default_fixture_dir();
  if verify_committed {
    if output_dir.is_some() {
      return Err(
        "--verify-committed cannot be combined with --output-dir".into(),
      );
    }
    return Ok(GeneratorMode::VerifyCommitted {
      fixtures_dir: default_dir,
    });
  }

  Ok(GeneratorMode::Write {
    output_dir: output_dir.unwrap_or(default_dir),
  })
}

fn default_fixture_dir() -> PathBuf {
  PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("fixtures")
}

fn verify_fixture_corpus(fixtures_dir: &Path) -> Result<Vec<String>, Box<dyn Error>> {
  let expected_map = fixture_corpus::generate_fixture_corpus()?
    .into_iter()
    .map(|(file_name, bytes)| (file_name.to_string(), bytes))
    .collect::<BTreeMap<_, _>>();
  let expected_names = expected_map
    .keys()
    .cloned()
    .collect::<BTreeSet<_>>();

  let committed_names = fs::read_dir(fixtures_dir)?
    .filter_map(|entry| entry.ok())
    .filter_map(|entry| {
      let file_name = entry.file_name();
      let file_name = file_name.to_str()?;
      file_name.ends_with(".xlsx").then_some(file_name.to_string())
    })
    .collect::<BTreeSet<_>>();
  if committed_names != expected_names {
    return Err(
      format!(
        "fixture corpus membership mismatch: expected {:?}, found {:?}",
        expected_names, committed_names
      )
      .into(),
    );
  }

  for (file_name, expected_bytes) in expected_map {
    let committed_bytes = fs::read(fixtures_dir.join(file_name.as_str()))?;
    if committed_bytes != expected_bytes {
      return Err(
        format!("fixture file '{file_name}' does not match generated bytes")
          .into(),
      );
    }
  }

  Ok(committed_names.into_iter().collect::<Vec<_>>())
}

#[cfg(test)]
mod tests {
  use super::fixture_corpus;
  use super::{
    default_fixture_dir, parse_mode, verify_fixture_corpus, GeneratorMode,
  };
  use std::{collections::HashSet, fs, path::PathBuf};
  use tempfile::tempdir;

  #[test]
  fn should_generate_fixture_workbooks_deterministically() {
    let first = fixture_corpus::generate_fixture_corpus()
      .expect("first fixture generation should succeed");
    let second = fixture_corpus::generate_fixture_corpus()
      .expect("second fixture generation should succeed");

    assert_eq!(
      first, second,
      "fixture binary output should be deterministic across repeated generation runs",
    );
  }

  #[test]
  fn should_parse_default_write_mode_with_default_output_dir() {
    let parsed = parse_mode(&[]).expect("default mode should parse");
    assert_eq!(
      parsed,
      GeneratorMode::Write {
        output_dir: default_fixture_dir()
      },
    );
  }

  #[test]
  fn should_parse_write_mode_with_explicit_output_dir_argument() {
    let parsed = parse_mode(&[
      "--output-dir".to_string(),
      "/tmp/custom-fixtures".to_string(),
    ])
    .expect("explicit output dir should parse");
    assert_eq!(
      parsed,
      GeneratorMode::Write {
        output_dir: PathBuf::from("/tmp/custom-fixtures")
      },
    );
  }

  #[test]
  fn should_reject_output_dir_argument_without_value() {
    let error = parse_mode(&["--output-dir".to_string()])
      .expect_err("missing output dir value should fail");
    assert!(
      error
        .to_string()
        .contains("--output-dir requires a following directory path"),
      "error should describe missing output dir path",
    );
  }

  #[test]
  fn should_reject_unknown_generator_argument() {
    let error = parse_mode(&["--unexpected".to_string()])
      .expect_err("unknown arg should fail");
    assert!(
      error
        .to_string()
        .contains("Supported args: --output-dir <path>, --verify-committed"),
      "error should describe supported args",
    );
  }

  #[test]
  fn should_parse_verify_committed_mode() {
    let parsed = parse_mode(&["--verify-committed".to_string()])
      .expect("verify mode should parse");
    assert_eq!(
      parsed,
      GeneratorMode::VerifyCommitted {
        fixtures_dir: default_fixture_dir()
      },
    );
  }

  #[test]
  fn should_reject_verify_mode_combined_with_output_dir() {
    let error = parse_mode(&[
      "--verify-committed".to_string(),
      "--output-dir".to_string(),
      "/tmp/custom-fixtures".to_string(),
    ])
    .expect_err("verify mode should reject output-dir");
    assert!(
      error
        .to_string()
        .contains("--verify-committed cannot be combined with --output-dir"),
      "error should describe invalid flag combination",
    );
  }

  #[test]
  fn should_write_expected_fixture_files_to_custom_output_dir() {
    let output_dir = tempdir()
      .expect("temp dir should create")
      .path()
      .join("generated-fixtures");
    let written_files = fixture_corpus::write_fixture_corpus(&output_dir)
      .expect("fixture corpus should write");
    let written_set = written_files
      .iter()
      .copied()
      .collect::<HashSet<_>>();

    let expected_set = fixture_corpus::fixture_corpus_file_names()
      .iter()
      .copied()
      .collect::<HashSet<_>>();
    assert_eq!(
      written_set, expected_set,
      "generator should emit the complete fixture corpus",
    );

    for file_name in expected_set {
      let fixture_path = output_dir.join(file_name);
      let metadata = fs::metadata(&fixture_path)
        .unwrap_or_else(|error| panic!("fixture {} should exist: {error}", fixture_path.display()));
      assert!(
        metadata.len() > 0,
        "fixture {} should be non-empty",
        fixture_path.display(),
      );
    }
  }

  #[test]
  fn should_verify_fixture_corpus_in_custom_output_dir() {
    let output_dir = tempdir()
      .expect("temp dir should create")
      .path()
      .join("generated-fixtures");
    fixture_corpus::write_fixture_corpus(&output_dir)
      .expect("fixture corpus should write");

    let verified_files = verify_fixture_corpus(&output_dir)
      .expect("written fixture corpus should verify");
    assert_eq!(verified_files.len(), fixture_corpus::fixture_corpus_file_names().len());
  }

  #[test]
  fn should_verify_committed_fixture_corpus_from_default_dir() {
    let verified_files = verify_fixture_corpus(&default_fixture_dir())
      .expect("committed fixture corpus should verify");
    assert_eq!(verified_files.len(), fixture_corpus::fixture_corpus_file_names().len());
  }

  #[test]
  fn should_fail_verify_when_fixture_file_is_missing() {
    let output_dir = tempdir()
      .expect("temp dir should create")
      .path()
      .join("generated-fixtures");
    fixture_corpus::write_fixture_corpus(&output_dir)
      .expect("fixture corpus should write");
    fs::remove_file(
      output_dir.join(fixture_corpus::COMPAT_PREFIX_OPERATOR_FILE_NAME),
    )
    .expect("fixture file should be removable");

    let error = verify_fixture_corpus(&output_dir)
      .expect_err("verification should fail when fixture file is missing");
    assert!(
      error
        .to_string()
        .contains("fixture corpus membership mismatch"),
      "verification error should describe membership mismatch",
    );
  }

  #[test]
  fn should_fail_verify_when_fixture_file_bytes_drift() {
    let output_dir = tempdir()
      .expect("temp dir should create")
      .path()
      .join("generated-fixtures");
    fixture_corpus::write_fixture_corpus(&output_dir)
      .expect("fixture corpus should write");
    fs::write(
      output_dir.join(fixture_corpus::COMPAT_FORMULA_MATRIX_FILE_NAME),
      b"tampered fixture bytes",
    )
    .expect("fixture bytes should be writable");

    let error = verify_fixture_corpus(&output_dir)
      .expect_err("verification should fail when fixture bytes drift");
    assert!(
      error
        .to_string()
        .contains("does not match generated bytes"),
      "verification error should describe byte mismatch",
    );
  }

  #[test]
  fn should_fail_verify_when_unexpected_fixture_file_is_present() {
    let output_dir = tempdir()
      .expect("temp dir should create")
      .path()
      .join("generated-fixtures");
    fixture_corpus::write_fixture_corpus(&output_dir)
      .expect("fixture corpus should write");
    fs::write(
      output_dir.join("unexpected_fixture.xlsx"),
      b"unexpected fixture bytes",
    )
    .expect("unexpected fixture file should be writable");

    let error = verify_fixture_corpus(&output_dir)
      .expect_err("verification should fail with unexpected fixture file");
    assert!(
      error
        .to_string()
        .contains("fixture corpus membership mismatch"),
      "verification error should describe membership mismatch",
    );
  }

  #[test]
  fn should_ignore_non_xlsx_sidecar_files_during_verification() {
    let output_dir = tempdir()
      .expect("temp dir should create")
      .path()
      .join("generated-fixtures");
    fixture_corpus::write_fixture_corpus(&output_dir)
      .expect("fixture corpus should write");
    fs::write(
      output_dir.join("notes.txt"),
      b"fixture readme sidecar",
    )
    .expect("sidecar file should be writable");

    let verified_files = verify_fixture_corpus(&output_dir)
      .expect("verification should ignore non-xlsx sidecar files");
    assert_eq!(verified_files.len(), fixture_corpus::fixture_corpus_file_names().len());
  }
}
